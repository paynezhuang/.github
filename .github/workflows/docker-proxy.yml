# 工作流名称
name: Mirror Docker Images to CNB

# 工作流触发器配置
on:
  # 允许手动触发工作流
  workflow_dispatch:
    inputs:
      # 定义一个名为 "registry" 的输入框
      registry:
        description: '覆盖默认的源镜像仓库地址 (留空则自动识别)'
        required: false
        type: string
      # 定义一个名为 "name" 的输入框
      name:
        description: '选择要同步的镜像 (留空则同步所有)'
        required: false
        type: choice
        # 定义下拉框中的可选镜像列表
        # 注意：如果 images.yml 变动，这里需要手动更新
        options:
          - ""
          - "icloudpd"
          - "nextcloud"
          - "vaultwarden"
          - "redis"
          - "nacos-server"
          - "mysql"
          - "postgresql"
          - "minio"
          - "rocketmq"
          - "rocketmq-dashboard"
          - "immich-server"
          - "forgejo"
          - "immich-machine-learning"
          - "valkey"
          - "immich-postgres"
      # 定义一个名为 "version" 的输入框
      version:
        description: '覆盖默认的镜像版本标签 (tag)'
        required: false
        type: string
  # 当 .github/images.yml 文件被推送到 main 分支时自动触发
  push:
    paths:
      - '.github/images.yml'
    branches: [ 'main' ]

# 定义工作流中的任务
jobs:
  # 任务ID为 "mirror"
  mirror:
    # 任务名称，会显示在 GitHub Actions 的 UI 界面
    # 它会根据手动触发时是否输入了镜像名和版本号来动态显示
    name: >-
      Mirror ${{ github.event.inputs.name || 'All Images' }}${{ github.event.inputs.version && format(' (version: {0})', github.event.inputs.version) || '' }}
    # 指定任务运行的虚拟环境
    runs-on: ubuntu-latest
    # 环境名称
    environment: DOCKERHUB-TO-CNB
    # 定义任务中的各个步骤
    steps:
      # 步骤1: 检出代码
      # 使用官方的 actions/checkout@v4 action 来获取仓库代码
      - name: Checkout code
        uses: actions/checkout@v4

      # 步骤2: 检查必要的变量是否已设置
      - name: Check required variables
        run: |
          if [ -z "${{ vars.CNB_USERNAME }}" ]; then
            echo "错误：CNB_USERNAME 变量未在仓库的 Settings -> Variables 中设置。"
            exit 1
          fi
          if [ -z "${{ vars.CNB_REPOSITORY }}" ]; then
            echo "错误：CNB_REPOSITORY 变量未在仓库的 Settings -> Variables 中设置。"
            exit 1
          fi

      # 步骤3: 同步镜像
      - name: Mirror images
        env:
          # 手动触发时输入的镜像名
          INPUT_NAME: ${{ github.event.inputs.name }}
          # 手动触发时输入的版本号
          INPUT_VERSION: ${{ github.event.inputs.version }}
          # 手动触发时输入的 registry
          INPUT_REGISTRY: ${{ github.event.inputs.registry }}
        # 运行的核心脚本
        run: |
          # 使用 yq 工具读取 images.yml 文件并转换为 json 格式
          # yq 是一个轻量级的命令行 YAML 处理器
          images=$(yq -o json '.images' ${{ github.workspace }}/.github/images.yml)

          # 判断是否手动指定了要同步的镜像名
          if [ -n "$INPUT_NAME" ]; then
            # 如果指定了，就从 json 中筛选出匹配的镜像信息
            matrix=$(echo "$images" | jq -c --arg name "$INPUT_NAME" '.[] | select(.name == $name)')
          else
            # 如果没指定，就选择所有的镜像
            matrix=$(echo "$images" | jq -c '.[]')
          fi

          # 检查筛选后是否找到了匹配的镜像
          if [ -z "$matrix" ]; then
            echo "未在 images.yml 中找到名为 '$INPUT_NAME' 的镜像配置"
            exit 1
          fi

          # 循环处理每个找到的镜像配置
          echo "$matrix" | while read -r item; do
            #
            # 从 json 对象中提取镜像的具体信息
            #
            # 原始镜像路径，如 "vaultwarden/server"
            image=$(echo "$item" | jq -r '.image')
            # 在你的仓库中使用的名称，如 "vaultwarden"
            name=$(echo "$item" | jq -r '.name')
            # 默认的版本标签
            default_tag=$(echo "$item" | jq -r '.tag')
            # 读取 yml 文件中的 registry 字段
            item_registry=$(echo "$item" | jq -r '.registry')
            
            #
            # 决定最终使用的版本标签和 registry
            # 优先级: 手动输入 > yml 文件定义 > 默认值 'docker.io'
            #
            tag=${INPUT_VERSION:-$default_tag}
            registry=${INPUT_REGISTRY:-${item_registry:-docker.io}}

            #
            # 构建源和目标镜像的完整 URL
            #
            source_image_url="docker://${registry}/${image}:${tag}"
            destination_image_url="docker://docker.cnb.cool/${{ vars.CNB_USERNAME }}/${{ vars.CNB_REPOSITORY }}/${name}:${tag}"

            # 打印将要执行的同步操作信息
            echo "正在同步 $source_image_url 到 $destination_image_url"

            #
            # 使用 bash 数组来动态、安全地构建 skopeo 命令
            #
            skopeo_args=( "copy" "--all" "$source_image_url" "$destination_image_url" "--dest-creds" "cnb:${{ secrets.CNB_DOCKER_TOKEN }}" )

            # 仅当源是 Docker Hub 时，才添加 Docker Hub 的拉取凭据
            if [ "$registry" = "docker.io" ]; then
              skopeo_args+=( "--src-creds" "${{ vars.DOCKERHUB_USERNAME }}:${{ secrets.DOCKERHUB_TOKEN }}" )
            fi

            # 执行 skopeo 命令
            skopeo "${skopeo_args[@]}"

            #
            # 在 GitHub Actions 的日志中输出一个醒目的通知，包含可以直接访问的镜像链接
            #
            echo "::notice title=镜像发布成功::https://docker.cnb.cool/${{ vars.CNB_USERNAME }}/${{ vars.CNB_REPOSITORY }}/${name}:${tag}"
          done